//1.	Write a program to display string "Computer Science and Engineering‚Äù for 8086.
ASSUME CS: CODE, DS:DATA
DATA SEGMENT
MSGE DB "Computer Science and Engineering$"
DATA ENDS
CODE SEGMENT
START:

MOV AX,DATA
MOV DS,AX
MOV DX,OFFSET MSGE
MOV AH,09H
INT 21H

MOV AH, 4CH
INT 21H

CODE ENDS
END START









//2.	Write an Assembly Language Program (ALP) to display multiple strings line by line.

ASSUME CS: CODE, DS:DATA
DATA SEGMENT
MSG DB "GEETHANJALI$"
MSG1 DB 0AH,"CSE$"

DATA ENDS
CODE SEGMENT
START:
MOV AX, DATA
MOV DS, AX
MOV DX, OFFSET MSG
MOV AH, 09H
INT 21H
LEA DX, MSG1
INT 21H
MOV AH, 4CH
INT 21H
CODE ENDS
END START











//max of 3
DATA SEGMENT
    LIST DB 1H, 5H, 3H
    COUNT EQU 03H
    MAX DB 01H DUP(?)
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA

START:
    MOV AX, DATA
    MOV DS, AX

    MOV SI, OFFSET LIST
    MOV CL, COUNT
    MOV AL, [SI]

AGAIN:
    CMP AL, [SI+1]
    JNL NEXT
    MOV AL, [SI+1]

NEXT:
    INC SI
    DEC CL
    CMP CL, 0H
    JG AGAIN

    MOV BL, AL
    ADD BL, '0'       ; Convert to ASCII
    MOV AH, 02H
    MOV DL, BL
    INT 21H

    MOV AH, 4CH
    MOV AL, 0H
    INT 21H

CODE ENDS
END START




//week 3 1. Print Numbers from 0 to 9
DATA SEGMENT
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE, DS:DATA
BEGIN: MOV AX,DATA
MOV DS,AX
MOV CX,10
MOV DL,48

L1: MOV AH,2
INT 21H
INC DL
LOOP L1

MOV AH,4CH
INT 21H
CODE ENDS
END BEGIN








//week 3 2.Check if Number is Even or Odd
ASSUME CS:CODE, DS:DATA
DATA SEGMENT
NL1 DB 10,'ENTER NUMBER:$'
NL2 DB 10,'ODD$'
NL3 DB 10,'EVEN$'
SN1 DB 0
DATA ENDS
CODE SEGMENT
START:
MOV AX,DATA
MOV DS,AX
LEA DX,NL1
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
TEST AL,01H
JZ SKIP1
LEA DX,NL2
MOV AH,09H
INT 21H

JMP SKIP2
SKIP1:
LEA DX,NL3
MOV AH,09H
INT 21H
SKIP2:
MOV AH,4CH
INT 21H
CODE ENDS
END START








//factorial
ASSUME CS:CODE
CODE SEGMENT
START:MOV AX,1
      MOV CX,5
LOOP1:MUL CX
      LOOP LOOP1
      MOV BX,10
      MOV SI,0
NEXT:XOR DX,DX
     DIV BX
     ADD DL,30H
     PUSH DX
     INC SI
     CMP AX,0
     JNZ NEXT
PRINT:POP DX
      MOV AH,02H
      INT 21H
      DEC SI
      JNZ PRINT
      MOV AH,4CH
      INT 21H
CODE ENDS
END START
	










//fibonacci
ASSUME CS:CODE
CODE SEGMENT
START:MOV AX,0
MOV BX,1
MOV CX,5
NEXT:PUSH AX
PUSH BX
CALL DISP
POP BX
POP AX
MOV DX,AX
ADD AX,BX
MOV BX,DX
LOOP NEXT
MOV AH,4CH
INT 21H
DISP:PUSH AX
MOV DX,AX
ADD DL,30H
MOV AH,02H
INT 21H
MOV DL,20H
INT 21H
POP AX
RET
CODE ENDS
END START








//sum
ASSUME CS:CODE, DS:DATA
DATA SEGMENT
NL1 DB 0AH,0DH,'ENTER HOW MANY NO U WANT:','$'
NL2 DB 0AH,0DH,'ENTER NO:','$'
DATA ENDS
CODE SEGMENT
MAIN PROC
MOV AX,DATA
MOV DS,AX
LEA DX,NL1
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
MOV CL,AL
MOV BL,00H
LBL1:
LEA DX,NL2
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
ADD BL,AL
LOOP LBL1
MOV DL,0AH
MOV AH,02H
INT 21H
MOV DL,0DH
INT 21H
MOV DL,BL
ADD DL,30H
INT 21H
MOV AH,4CH
INT 21H
MAIN ENDP
CODE ENDS
END MAIN










//minmax
ASSUME CS:CODE, DS:DATA
DATA SEGMENT
NL1 DB 0AH,0DH,'ENTER HOW MANY NO:','$'
NL2 DB 0AH,0DH,'ENTER NO:','$'
NL3 DB 0AH,0DH,'MAX:','$'
NL4 DB 0AH,0DH,'MIN:','$'
DATA ENDS
CODE SEGMENT
MAIN PROC
MOV AX,DATA
MOV DS,AX
LEA DX,NL1
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
MOV CL,AL
LEA DX,NL2
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
MOV BH,AL
MOV BL,AL
DEC CL
CMP CL,0
JE DISPLAY
LBL1:
LEA DX,NL2
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
CMP AL,BH
JG UPDATE_MAX
JMP CHK_MIN
UPDATE_MAX:
MOV BH,AL
CHK_MIN:
CMP AL,BL
JL UPDATE_MIN
JMP NEXT
UPDATE_MIN:
MOV BL,AL
NEXT:
LOOP LBL1
DISPLAY:
LEA DX,NL3
MOV AH,09H
INT 21H
MOV DL,BH
ADD DL,30H
MOV AH,02H
INT 21H
LEA DX,NL4
MOV AH,09H
INT 21H
MOV DL,BL
ADD DL,30H
MOV AH,02H
INT 21H
MOV AH,4CH
INT 21H
MAIN ENDP
CODE ENDS
END MAIN











//transfer a block of data
ASSUME CS:CODE
DATA SEGMENT
SRC DB 'A','B','C','D','E'
DEST DB 5 DUP(?)
DATA ENDS
CODE SEGMENT
START: MOV AX,DATA
MOV DS,AX
LEA SI,SRC
LEA DI,DEST
MOV CX,5
MOVE: MOV AL,[SI]
MOV [DI],AL
INC SI
INC DI
LOOP MOVE
LEA SI,DEST
MOV CX,5
PRINT: MOV DL,[SI]
MOV AH,02H
INT 21H
INC SI
LOOP PRINT
MOV AH,4CH
INT 21H
CODE ENDS
END START










//reverse a string
ASSUME CS:CODE, DS:DATA

DATA SEGMENT
    STR DB 'COMPUTER$'
    LEN EQU $-STR-1
    REV DB 20 DUP ('$')
DATA ENDS

CODE SEGMENT
START: 
    MOV AX, DATA
    MOV DS, AX
    
    LEA SI, STR
    LEA DI, REV
    MOV CX, LEN
    ADD SI, CX
    DEC SI

REV_LOOP: 
    MOV AL, [SI]
    MOV [DI], AL
    INC DI
    DEC SI
    LOOP REV_LOOP

    MOV BYTE PTR [DI], '$'
    
    LEA DX, REV
    MOV AH, 09H
    INT 21H

    MOV AH, 4CH
    INT 21H

CODE ENDS
END START







//linear search
ASSUME CS:CODE, DS:DATA

DATA SEGMENT
    LIST DB 2, 3, 5, 8
    COUNT DB 4
    MSG1 DB 'ENTER ELEMENT: $'
    MSG2 DB 13, 10, 'ELEMENT FOUND $'
    MSG3 DB 13, 10, 'ELEMENT NOT FOUND $'
DATA ENDS

CODE SEGMENT
START:
    MOV AX, DATA
    MOV DS, AX
    
    LEA DX, MSG1
    MOV AH, 09H
    INT 21H
    
    MOV AH, 01H
    INT 21H
    SUB AL, 30H
    
    LEA SI, LIST
    MOV CL, COUNT
    MOV CH, 0

SEARCH:
    CMP AL, [SI]
    JE FOUND
    INC SI
    DEC CL
    JNZ SEARCH
    
    LEA DX, MSG3
    JMP DISPLAY

FOUND:
    LEA DX, MSG2

DISPLAY:
    MOV AH, 09H
    INT 21H
    
    MOV AH, 4CH
    INT 21H

CODE ENDS
END START









//sorting
ASSUME CS:CODE, DS:DATA
DATA SEGMENT
    N DB ?
    ARR DB 100 DUP(?)
    MSG1 DB 'Enter number of elements: $'
    MSG2 DB 'Enter element: $'
    MSG3 DB 'Sorted order: $'
    NL DB 0DH,0AH,'$'
DATA ENDS

CODE SEGMENT
START:
    MOV AX,DATA
    MOV DS,AX
    
    LEA DX,MSG1
    MOV AH,09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    SUB AL,30H
    MOV N,AL
    MOV CL,AL
    
    LEA DX,NL
    MOV AH,09H
    INT 21H
    
    MOV BX,00H
    
INPUT:
    LEA DX,MSG2
    MOV AH,09H
    INT 21H
    
    MOV AH,01H
    INT 21H
    SUB AL,30H
    MOV ARR[BX],AL
    INC BX
    
    LEA DX,NL
    MOV AH,09H
    INT 21H
    
    DEC CL
    JNZ INPUT

    MOV CL,N
    DEC CL

SORT:
    MOV BX,00H
    MOV CH,CL
    
COMP:
    MOV AL,ARR[BX]
    CMP AL,ARR[BX+1]
    JBE SKIP
    MOV DL,ARR[BX+1]
    MOV ARR[BX+1],AL
    MOV ARR[BX],DL

SKIP:
    INC BX
    DEC CH
    JNZ COMP
    DEC CL
    JNZ SORT

    LEA DX,MSG3
    MOV AH,09H
    INT 21H
    
    MOV BX,00H
    MOV CL,N

OUTPUT:
    MOV AL,ARR[BX]
    ADD AL,30H
    MOV DL,AL
    MOV AH,02H
    INT 21H
    
    MOV DL,20H
    MOV AH,02H
    INT 21H
    
    INC BX
    DEC CL
    JNZ OUTPUT
    
    MOV AH,4CH
    INT 21H

CODE ENDS
END START








